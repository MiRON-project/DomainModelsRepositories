//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#ifndef COMMMANIPULATOROBJECTS_COMMMANIPULATORSTATE_H_
#define COMMMANIPULATOROBJECTS_COMMMANIPULATORSTATE_H_

#include "CommManipulatorObjects/CommManipulatorStateCore.hh"

namespace CommManipulatorObjects {
		
class CommManipulatorState : public CommManipulatorStateCore {
	public:
		// default constructors
		CommManipulatorState();
		
		/**
		 * Constructor to set all values.
		 * NOTE that you have to keep this constructor consistent with the model!
		 * Use  at your own choice.
		 *
		 * The preferred way to set values for initialization is:
		 *      CommRepository::MyCommObject obj;
		 *      obj.setX(1).setY(2).setZ(3)...;
		 */
		// CommManipulatorState(const unsigned int &id, const std::vector<double> &joint_angles, const CommBasicObjects::CommPose3d &pose_tcp, const CommBasicObjects::CommPose3d &pose_manipulator, const bool &is_valid = false);
		
		CommManipulatorState(const CommManipulatorStateCore &commManipulatorState);
		CommManipulatorState(const DATATYPE &commManipulatorState);
		virtual ~CommManipulatorState();
		
		// use framework specific getter and setter methods from core (base) class
		using CommManipulatorStateCore::get;
		using CommManipulatorStateCore::set;
		
		//
		// feel free to add customized methods here
		//

		inline unsigned int getId() const
		{
			return idl_CommManipulatorState.id;
		}
		inline void setId(const unsigned int &id)
		{
			idl_CommManipulatorState.id = id;
		}

		inline bool getIs_valid() const
		{
			return idl_CommManipulatorState.is_valid;
		}
		inline void setIs_valid(const bool &is_valid)
		{
			idl_CommManipulatorState.is_valid = is_valid;
		}

		inline std::vector<double>& getJoint_anglesRef()
		{
			return idl_CommManipulatorState.joint_angles;
		}

		inline CommBasicObjects::CommPose3d getPose_manipulator() const
		{
			return CommBasicObjects::CommPose3d(
					idl_CommManipulatorState.pose_manipulator);
		}
		inline void setPose_manipulator(
				const CommBasicObjects::CommPose3d &pose_manipulator)
		{
			idl_CommManipulatorState.pose_manipulator = pose_manipulator;
		}

		inline CommBasicObjects::CommPose3d getPose_tcp() const
		{
			return CommBasicObjects::CommPose3d(idl_CommManipulatorState.pose_tcp);
		}
		inline void setPose_tcp(const CommBasicObjects::CommPose3d &pose_tcp)
		{
			idl_CommManipulatorState.pose_tcp = pose_tcp;
		}

		//
		// add your customized interface here
		//

			/**
		 * Set the number of joints the manipulator has.
		 * @param jointCount Number of joints
		 */
		inline void set_joint_count(const size_t jointCount) {
			idl_CommManipulatorState.joint_angles.resize(jointCount);
		}

		/**
		 * Return the number of joints the manipulator has.
		 * @return Number of joints
		 */
		inline size_t get_joint_count() const {
			return idl_CommManipulatorState.joint_angles.size();
		}

		/**
		 * Set angle of a joint.
		 * @param joint Index of the joint
		 * @param angle Anlge for the joint [rad]
		 */
		inline void set_joint_angle(const size_t joint, const double angle) {
			idl_CommManipulatorState.joint_angles[joint] = angle;
		}

		/**
		 * Return the angle for a joint.
		 * @param joint Index of the joint
		 * @return Angle for the joint [rad]
		 */
		inline double get_joint_angle(const size_t joint) const {
			return idl_CommManipulatorState.joint_angles[joint];
		}

		/**
		 * Set the pose of the tool center point relative to the
		 * coordinate system of the manipulator. The position
		 * is specified in the given unit value (0.001 = mm)
		 * @param x value of the pose
		 * @param y value of the pose
		 * @param z value of the pose
		 * @param phi value of the pose [rad]
		 * @param theta value of the pose [rad]
		 * @param psi value of the pose [rad]
		 */
		inline void set_pose_TCP_manipulator(const double x, const double y, const double z, const double azimuth,
				const double elevation, const double roll, const double unit = 0.001) {
			idl_CommManipulatorState.pose_tcp.position.x = x * unit * 1000;
			idl_CommManipulatorState.pose_tcp.position.y = y * unit * 1000;
			idl_CommManipulatorState.pose_tcp.position.z = z * unit * 1000;

			idl_CommManipulatorState.pose_tcp.orientation.azimuth = azimuth;
			idl_CommManipulatorState.pose_tcp.orientation.elevation = elevation;
			idl_CommManipulatorState.pose_tcp.orientation.roll = roll;
		}

		/**
		 * Set the pose of the manipulator coordinate system relative
		 * to the robot coordinate system.
		 */
		inline void set_pose_manipulator(const double x, const double y, const double z, const double azimuth,
				const double elevation, const double roll, const double unit = 0.001) {
			idl_CommManipulatorState.pose_manipulator.position.x = x * unit * 1000;
			idl_CommManipulatorState.pose_manipulator.position.y = y * unit * 1000;
			idl_CommManipulatorState.pose_manipulator.position.z = z * unit * 1000;

			idl_CommManipulatorState.pose_manipulator.orientation.azimuth = azimuth;
			idl_CommManipulatorState.pose_manipulator.orientation.elevation = elevation;
			idl_CommManipulatorState.pose_manipulator.orientation.roll = roll;
		}

		/**
		 * Return the pose of the tool center point relative to the
		 * coordinate system of the manipulator. The position is
		 * specified in the given unit value (0.001 = mm)
		 * @param x value of the pose
		 * @param y value of the pose
		 * @param z value of the pose
		 * @param azimuth value of the pose [rad]
		 * @param elevation value of the pose [rad]
		 * @param roll value of the pose [rad]
		 */
		inline void get_pose_TCP_manipulator(double& x, double& y, double& z, double& azimuth, double& elevation,
				double& roll, const double unit = 0.001) const {
			x = idl_CommManipulatorState.pose_tcp.position.x * 0.001 / unit;
			y = idl_CommManipulatorState.pose_tcp.position.y * 0.001 / unit;
			z = idl_CommManipulatorState.pose_tcp.position.z * 0.001 / unit;

			azimuth = idl_CommManipulatorState.pose_tcp.orientation.azimuth;
			elevation = idl_CommManipulatorState.pose_tcp.orientation.elevation;
			roll = idl_CommManipulatorState.pose_tcp.orientation.roll;
		}

		/**
		 * Returns the pose of the TCP (tool center point) in the
		 * coordinate system of the robot. The position is
		 * specified in the given unit value (0.001 = mm)
		 */
		inline void get_pose_TCP_robot(double& x, double& y, double& z, double& azimuth, double& elevation, double& roll,
				const double unit = 0.001) const {

			CommBasicObjects::CommPose3d pose_tcp(idl_CommManipulatorState.pose_tcp);
			arma::mat mat_tcp = pose_tcp.getHomogeneousMatrix(unit);

			CommBasicObjects::CommPose3d pose_manipulator(idl_CommManipulatorState.pose_manipulator);
			arma::mat mat_manipulator = pose_manipulator.getHomogeneousMatrix(unit);

			arma::mat mat_tcp_robot = mat_manipulator * mat_tcp;
			CommBasicObjects::CommPose3d pose_tcp_robot(mat_tcp_robot, unit);
			x = pose_tcp_robot.get_x(unit);
			y = pose_tcp_robot.get_y(unit);
			z = pose_tcp_robot.get_z(unit);

			azimuth = pose_tcp_robot.get_azimuth();
			elevation = pose_tcp_robot.get_elevation();
			roll = pose_tcp_robot.get_roll();
		}

		/**
		 * Returns the pose of the manipulator coordinate system
		 * relative to the robot coordinate system. The position is
		 * specified in the given unit value (0.001 = mm)
		 */
		inline void get_pose_manipulator(double& x, double& y, double& z, double& azimuth, double& elevation, double& roll,
				const double unit = 0.001) const {
			x = idl_CommManipulatorState.pose_manipulator.position.x * 0.001 / unit;
			y = idl_CommManipulatorState.pose_manipulator.position.y * 0.001 / unit;
			z = idl_CommManipulatorState.pose_manipulator.position.z * 0.001 / unit;

			azimuth = idl_CommManipulatorState.pose_manipulator.orientation.azimuth;
			elevation = idl_CommManipulatorState.pose_manipulator.orientation.elevation;
			roll = idl_CommManipulatorState.pose_manipulator.orientation.roll;
		}

		/**
		 * Set the continuous id. Each object has an unique id which is
		 * incremented for each new state
		 * @param id Continuous id.
		 */
		inline void set_id(const unsigned int id) {
			idl_CommManipulatorState.id = id;
		}

		/**
		 * Get the continuous id. Each object has an unique id which is
		 * incremented for each new state
		 * @return Continuous id.
		 */
		inline unsigned int get_id() const {
			return idl_CommManipulatorState.id;
		}

		/**
		 * Set the state to valid or invalid.
		 * @param valid
		 * 			true	: state is valid
		 * 			false	: state is invalid
		 */
		inline void set_valid(const bool valid) {
			idl_CommManipulatorState.is_valid = valid;
		}

		/**
		 * Check if the state is valid.
		 * @return
		 * 			true	: state is valid
		 * 			false	: state is invalid
		 */
		inline bool is_valid() const {
			return idl_CommManipulatorState.is_valid;
		}

		/**
		 * Print the object to an output stream.
		 * @param os Output stream to which should be printed
		 */
		void print(std::ostream &os = std::cout) const;
};

inline std::ostream &operator<<(std::ostream &os, const CommManipulatorState &co)
{
	co.to_ostream(os);
	return os;
}
	
} /* namespace CommManipulatorObjects */
#endif /* COMMMANIPULATOROBJECTS_COMMMANIPULATORSTATE_H_ */
