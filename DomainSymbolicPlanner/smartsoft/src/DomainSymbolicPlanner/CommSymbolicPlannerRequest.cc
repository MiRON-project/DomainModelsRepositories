//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2010/2011 Andreas Steck
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Communication Classes".
//  It provides basic standardized data types for communication between
//  different components in the mobile robotics context. These classes
//  are designed to be used in conjunction with the SmartSoft Communication
//  Library.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "DomainSymbolicPlanner/CommSymbolicPlannerRequest.hh"



#include <cmath>
#include <string.h>
#include <iostream>
#include <iomanip>

#ifndef LISP_SEPARATOR
#define LISP_SEPARATOR " ()\"\n"
#define LISP_STRING    1000
#endif

#define CONTENT_SEPARATOR "[]"

#if defined(_WIN32) || defined(_WIN64)
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#define strcasecmp _stricmp
#define strncasecmp _strnicmp

#include "mystrsep.hh"

#endif

using namespace DomainSymbolicPlanner;






CommSymbolicPlannerRequest::CommSymbolicPlannerRequest()
:	CommSymbolicPlannerRequestCore()
{  }


/**
 * Constructor to set all values.
 * NOTE that you have to keep this constructor consistent with the model!
 * Use  at your own choice.
 *
 * The preferred way to set values for initialization is:
 *      CommRepository::MyCommObject obj;
 *      obj.setX(1).setY(2).setZ(3)...;
CommSymbolicPlannerRequest::CommSymbolicPlannerRequest(const std::string &plannertype, const std::string &domaindescription, const std::string &factdescription)
:	CommSymbolicPlannerRequestCore() // base constructor sets default values as defined in the model
{
	setPlannertype(plannertype);
	setDomaindescription(domaindescription);
	setFactdescription(factdescription);
}
 */

CommSymbolicPlannerRequest::CommSymbolicPlannerRequest(const CommSymbolicPlannerRequestCore &commSymbolicPlannerRequest)
:	CommSymbolicPlannerRequestCore(commSymbolicPlannerRequest)
{  }

CommSymbolicPlannerRequest::CommSymbolicPlannerRequest(const DATATYPE &commSymbolicPlannerRequest)
:	CommSymbolicPlannerRequestCore(commSymbolicPlannerRequest)
{  }

CommSymbolicPlannerRequest::~CommSymbolicPlannerRequest()
{  }


int CommSymbolicPlannerRequest::set(std::string inString)
{
	char* param = (char*)NULL;
	char* input = (char*)NULL;

	int error;
	int flagDomain;
	int flagFact;
	int flagPlannerType;

	// remove "
	std::string::size_type k = 0;
	while((k = inString.find('"',k)) != inString.npos)
	{
		inString.erase(k, 1);
	}

	input        		= (char*)inString.c_str();
	error        		= 0;

	flagDomain 			= 0;
	flagFact     		= 0;
	flagPlannerType 	= 0;

	// we don't know the order of the keywords "operator", "fact" and "result"
	do
	{
	    do
	    {

	    	param = strsep(&input, LISP_SEPARATOR);
			//param = strtok(input, LISP_SEPARATOR);
	    } while ((param != NULL) && (strlen(param)==0));

		std::cout<<" param: "<<param<<std::endl;
	    // PLANNERTYPE
		if ((strcasecmp(param, "planner") == 0) && (flagPlannerType == 0))
	    {
	      //
	      // get parameter of "planner" keyword
	      //
	      do
	      {
	    	  param = strsep(&input, LISP_SEPARATOR);
			  //param = strtok(input, LISP_SEPARATOR);
	      } while ((param != NULL) && (strlen(param)==0));

 	      idl_CommSymbolicPlannerRequest.plannertype = (const char*)param;

	      flagPlannerType = 1;
	    }

	    // OPERATOR
		else if ((strcasecmp(param, "domain") == 0) && (flagDomain == 0))
	    {
	      //
	      // get parameter of "operator" keyword
	      //
	      do
	      {
			  //param = strtok(input, CONTENT_SEPARATOR);
			  param = strsep(&input, CONTENT_SEPARATOR);
	      } while ((param != NULL) && (strlen(param)==0));

	      idl_CommSymbolicPlannerRequest.domaindescription = (const char*)param;

	      flagDomain = 1;
	    }

	    // FACT
		else if ((strcasecmp(param, "fact") == 0) && (flagFact == 0))
	    {
	      //
	      // get parameter of "fact" keyword
	      //
	      do
	      {
			  //param = strtok(input, CONTENT_SEPARATOR);
			  param = strsep(&input, CONTENT_SEPARATOR);
	      } while ((param != NULL) && (strlen(param)==0));

	      idl_CommSymbolicPlannerRequest.factdescription = (const char*)param;

	      flagFact = 1;
	    }

	    // ELSE
	    else
	    {
	      std::cout << "commSymbolicPlannerRequest::set -- ERROR -- ELSE \n";
	      std::cout<<" param: "<<param<<" tagplanner: "<<flagPlannerType<<std::endl;
	      if ((strcasecmp(param, "planner") == 0))
	      {
	    	  	 std::cout<<"Matched Planner"<<std::endl;
	      }
	      error = -1;
	    }
	  } while ((error == 0) && ((flagDomain==0) || (flagFact==0) || (flagPlannerType==0)));

	  return error;

}


int CommSymbolicPlannerRequest::getPlannerType(std::string &name) const
{
	  name = idl_CommSymbolicPlannerRequest.plannertype.c_str();
	  return 0;
}


int CommSymbolicPlannerRequest::getDomainDescription(std::string &name) const
{
	  name = idl_CommSymbolicPlannerRequest.domaindescription.c_str();
	  return 0;
}


int CommSymbolicPlannerRequest::getFactDescription(std::string &name) const
{
	  name = idl_CommSymbolicPlannerRequest.factdescription.c_str();
	  return 0;
}

